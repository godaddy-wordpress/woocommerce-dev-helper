<?php
/**
 * WooCommerce Dev Helper
 *
 * This source file is subject to the GNU General Public License v3.0
 * that is bundled with this package in the file license.txt.
 * It is also available through the world-wide-web at this URL:
 * http://www.gnu.org/licenses/gpl-3.0.html
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@skyverge.com so we can send you a copy immediately.
 *
 * @author    SkyVerge
 * @copyright Copyright (c) 2015-2018, SkyVerge, Inc.
 * @license   http://www.gnu.org/licenses/gpl-3.0.html GNU General Public License v3.0
 */

namespace SkyVerge\WooCommerce\Dev_Helper\Tools\Memberships;

defined( 'ABSPATH' ) or exit;

use SkyVerge\WooCommerce\PluginFramework\v5_2_0 as Framework;

/**
 * Memberships Bulk Generator.
 *
 * Tool to generate membership objects in bulk.
 *
 * @see Bulk_Destroyer counterpart
 *
 * @since 1.0.0
 *
 * @method \stdClass update_job( $job )
 */
class Bulk_Generator extends Framework\SV_WP_Background_Job_Handler {


	/** @var string the option key used to store object IDs generated by this background job */
	private $generated_objects_ids_option_key = 'wc_dev_helper_memberships_bulk_generated_objects';


	/**
	 * Background job constructor.
	 *
	 * @since 1.0.0
	 */
	public function __construct() {

		$this->prefix   = 'wc_dev_helper';
		$this->action   = 'memberships_bulk_generation';
		$this->data_key = 'members';

		parent::__construct();
	}


	/**
	 * Returns an array of object keys used in the job.
	 *
	 * Each key should have a corresponding array of object IDs to record objects being created while the job is running.
	 *
	 * @since 1.0.0
	 *
	 * @return string[]
	 */
	public function get_objects_keys() {

		// deletion will later follow the array key order:
		return array(
			'memberships',
			'posts',
			'categories',
			'products',
			'product_cats',
			'orders',
			'subscriptions',
			'plans',
			'users',
		);
	}


	/**
	 * Returns an associative array of generated object IDs.
	 *
	 * @since 1.0.0
	 *
	 * @return array
	 */
	public function get_generated_objects_ids() {

		return get_option( $this->generated_objects_ids_option_key, array() );
	}


	/**
	 * Saves generated object IDs to an option.
	 *
	 * @since 1.0.0
	 *
	 * @param array|\stdClass $data associative array
	 * @return bool success
	 */
	public function set_generated_objects_ids( $data ) {

		$raw_data       = ! empty( $data ) ? (array) $data : null;
		$validated_data = array();

		if ( ! empty( $raw_data ) ) {

			$valid_keys = $this->get_objects_keys();

			foreach ( $raw_data as $object_name => $object_ids ) {

				$object_ids = (array) $object_ids;

				if ( in_array( $object_name, $valid_keys, true ) ) {

					$validated_data[ $object_name ] = array_unique( array_map( 'absint', $object_ids ) );
				}
			}
		}

		return update_option( $this->generated_objects_ids_option_key, $validated_data ) && ! empty( $validated_data );
	}


	/**
	 * Deletes the option that stores all the generated objects IDs.
	 *
	 * @since 1.0.0
	 *
	 * @return bool success
	 */
	public function delete_generated_objects_ids() {

		return delete_option( $this->generated_objects_ids_option_key );
	}


	/**
	 * Creates a new job.
	 *
	 * @since 1.0.0
	 *
	 * @param array $args array of arguments
	 * @return \stdClass
	 */
	public function create_job( $args ) {

		$existing = $this->get_generated_objects_ids();
		$objects  = array();

		foreach ( $this->get_objects_keys() as $key ) {
			$objects[ $key ] = ! empty( $existing[ $key ] ) ? $existing[ $key ] : array();
		}

		$args = wp_parse_args( $args, array(
			'members' => array(),
			'objects' => $objects,
		) );

		return parent::create_job( $args );
	}


	/**
	 * Completes the job and saves the created object IDs inside an option.
	 *
	 * @since 1.0.0
	 *
	 * @param false|object|\stdClass $job job object
	 * @return \stdClass
	 */
	public function complete_job( $job ) {

		$this->save_generated_object_ids( $job );

		return parent::complete_job( $job );
	}


	/**
	 * Deletes the job, but saves the created object IDs first.
	 *
	 * @since 1.0.0
	 *
	 * @param \stdClass $job job object
	 */
	public function delete_job( $job ) {

		$this->save_generated_object_ids( $job );

        parent::delete_job( $job );
	}


	/**
	 * Saves generated object IDs (helper method).
	 *
	 * @since 1.0.0
	 *
	 * @param false|\stdClass $job job object
	 * @return bool
	 */
	private function save_generated_object_ids( $job ) {

		$success = false;

		if ( is_object( $job ) ) {

			$option_data     = array();
			$created_objects = isset( $job->objects ) ? (array) $job->objects : array();

			if ( ! empty( $created_objects ) ) {
				foreach ( $created_objects as $object_name => $object_ids ) {
					$option_data[ $object_name ] = (array) $object_ids;
				}
			}

			$success = $this->set_generated_objects_ids( $option_data );
		}

		return $success;
	}


	/**
	 * Processes a job.
	 *
	 * Implements parent method, but with some minor difference.
	 * For example, the processed item updates the job object.
	 * The results will be used at the end for storing the generated object IDs.
	 *
	 * @since 1.0.0
	 *
	 * @param \stdClass $job job object
	 * @param int $items_per_batch number of items to process in a single request (defaults to unlimited)
	 * @return \stdClass $job
	 * @throws Framework\SV_WC_Plugin_Exception when job data is incorrect or an error occurred
	 */
	public function process_job( $job, $items_per_batch = null ) {

		if ( ! $this->start_time ) {
			$this->start_time = time();
		}

		// indicates that the job has started processing
		if ( 'processing' !== $job->status ) {

			$job->status                = 'processing';
			$job->started_processing_at = current_time( 'mysql' );

			$job = $this->update_job( $job );
		}

		$data_key = $this->data_key;

		if ( ! isset( $job->{$data_key} ) ) {
			throw new Framework\SV_WC_Plugin_Exception( sprintf( __( 'Job data key "%s" not set', 'woocommerce-dev-helper' ), $data_key ) );
		}

		if ( ! is_array( $job->{$data_key} ) ) {
			throw new Framework\SV_WC_Plugin_Exception( sprintf( __( 'Job data key "%s" is not an array', 'woocommerce-dev-helper' ), $data_key ) );
		}

		$data = $job->{$data_key};

		$job->total = count( $data );

		// progress indicates how many items have been processed, it
		// does NOT indicate the processed item key in any way
		if ( ! isset( $job->progress ) ) {
			$job->progress = 0;
		}

		// skip already processed items
		if ( $job->progress && ! empty( $data ) ) {
			$data = array_slice( $data, $job->progress, null, true );
		}

		// loop over unprocessed items and process them
		if ( ! empty( $data ) ) {

			$processed       = 0;
			$items_per_batch = (int) $items_per_batch;

			foreach ( $data as $item ) {

				// process the item (may throw exception)
				$job = $this->process_item( $item, $job );

				$processed++;
				$job->progress++;

				// update job progress
				$job = $this->update_job( $job );

				// job limits reached
				if ( ( $items_per_batch && $processed >= $items_per_batch ) || $this->time_exceeded() || $this->memory_exceeded() ) {
					break;
				}
			}
		}

		// complete current job
		if ( $job->progress >= count( $job->{$data_key} ) ) {
			$job = $this->complete_job( $job );
		}

		return $job;
	}


	/**
	 * Processes an item and creates a user membership assigned to a user.
	 *
	 * This may trigger a cascade of objects that need to be created.
	 * For example, to create a user membership, an user must exist first.
	 * A plan to be assigned must exist as well. A plan contains references to other WordPress/WooCommerce objects and so on...
	 *
	 * @since 1.0.0
	 *
	 * @param string $user_login item to process
	 * @param \stdClass $job job object
	 * @return \stdClass modified job object
	 */
	public function process_item( $user_login, $job ) {

		return $this->create_user_membership( $this->get_user( $user_login ), $job );
	}


	/**
	 * Creates a user membership for a user.
	 *
	 * Membership details and plan assignment are randomly chosen.
	 *
	 * @since 1.0.0
	 *
	 * @param \WP_User $user user object
	 * @param \stdClass $job job object
	 * @return \stdClass $job updated job object with generated object IDs
	 */
	private function create_user_membership( $user, $job ) {

		if ( $user instanceof \WP_User ) {

			// record the user ID
			$job   = $this->record_object_id( $job, 'users', $user->ID );
			$slugs = $this->get_membership_plans_slugs();

			// each user gets randomly assigned 1 or 2 plans
			// TODO turn this into a generator setting to have a variable number or even the possibility to skip a membership for some generated users
			$plan_slugs = array_rand( array_combine( $slugs, $slugs ), mt_rand( 1, 2 ) );

			if ( ! empty( $plan_slugs ) && is_array( $plan_slugs ) )  {

				foreach ( $plan_slugs as $plan_slug ) {

					// unless previously generated, this may also trigger a plan creation, with a cascade of objects attached to it
					if ( $membership_plan = $this->get_membership_plan( $plan_slug ) ) {

						// stores a record of new objects created during plan creation
						$job = $this->record_objects_ids( $membership_plan, $job );

						// do not use `wc_memberships_create_user_membership()` to reduce a bit of overhead
						$post_id = wp_insert_post( array(
							'post_parent'    => $membership_plan->get_id(),
							'post_author'    => $user->ID,
							'post_type'      => 'wc_user_membership',
							'post_status'    => 'wcm-active',
							'comment_status' => 'open',
						) );

						if ( is_numeric( $post_id ) ) {

							// record the user membership ID just created
							$job = $this->record_object_id( $job, 'memberships', $post_id );

							$user_membership = new \WC_Memberships_User_Membership( $post_id );

							$now = current_time( 'timestamp', true );

							if ( $user_membership->get_plan()->is_access_length_type( 'fixed' ) ) {
								$start_time = mt_rand( $now - YEAR_IN_SECONDS, $now + MONTH_IN_SECONDS );
							} else {
								$start_time = mt_rand( $now - MONTH_IN_SECONDS, $user_membership->get_plan()->get_access_start_date( 'timestamp' ) );
							}

							// set dates and expiration events
							$user_membership->set_start_date( date( 'Y-m-d H:i:s', $start_time ) );
							$user_membership->set_end_date( $user_membership->get_end_date( 'timestamp' ) );

							// some memberships will be randomly paused, others may be delayed, a few less may be cancelled
							if ( $user_membership->is_active() && 'delayed' !== $user_membership->get_status() ) {

								$random_number = mt_rand( 1, 35 );

								if ( 1 === $random_number ) {
									$user_membership->cancel_membership( __( 'Membership randomly cancelled during automatic bulk generation.', 'woocommerce-dev-helper' ) );
								} elseif ( $random_number > 32 ) {
									$user_membership->pause_membership( __( 'Membership randomly paused during automatic bulk generation.', 'woocommerce-dev-helper' ) );
								}
							}
						}
					}
				}
			}
		}

		return $job;
	}


	/**
	 * Returns a customer user, or creates one if not found.
	 *
	 * @since 1.0.0
	 *
	 * @param $which_user
	 * @return bool|null|\WP_User
	 */
	private function get_user( $which_user ) {

		$login = $this->add_prefix( $which_user );
		$user  = get_user_by( 'login', $login );

		if ( ! $user ) {
			$user = $this->create_user( $which_user );
		}

		return $user;
	}


	/**
	 * Creates a user customer.
	 *
	 * @since 1.0.0
	 *
	 * @param string $user_login user login slug
	 * @return null|\WP_User
	 */
	private function create_user( $user_login ) {

		$user    = null;
		$login   = $this->add_prefix( $user_login );
		$user_id = wp_insert_user( array(
			'user_login' => $login,
			'user_pass'  => wp_generate_password(),
			// e.g. `wc_dev_helper_user_123@example.com`
			'user_email' => str_replace( array( '-', ' ' ), '_', trim( "{$login}@example.com" ) ),
			'role'       => 'customer',
		) );

		if ( is_numeric( $user_id ) ) {
			$user = get_user_by( 'id', $user_id );
		}

		return $user instanceof \WP_User ? $user : null;
	}


	/**
	 * Returns slugs of all users to be generated in a process.
	 *
	 * @see AJAX::start_bulk_generate_memberships()
	 *
	 * @since 1.0.0
	 *
	 * @param int $limit maximum number of users generated
	 * @return string[] array of user slugs
	 */
	public function generate_users_slugs( $limit ) {

		$users = array();

		for ( $i = 1; $i <= $limit; $i++ ) {

			// pads the user $id string so it stays alphabetical
			$id = str_pad( (string) $i, max( 1, strlen( (string) $limit ) ), '0', STR_PAD_LEFT );

			// eg. `wc_dev_helper_user_00123` when $limit is 10000
			$users[] = $this->add_prefix( "user_{$id}" );
		}

		return $users;
	}


	/**
	 * Returns a membership plan.
	 *
	 * May create the plan if not found, then return it.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_plan membership plan slug
	 * @return null|\WC_Memberships_Integration_Subscriptions_Membership_Plan|\WC_Memberships_Membership_Plan
	 */
	private function get_membership_plan( $which_plan ) {

		$plan      = null;
		$plan_data = $this->get_membership_plan_data( $which_plan );
		$plan_slug = $this->add_prefix( $which_plan );

		if ( ! empty( $plan_data ) ) {

			$plan = wc_memberships_get_membership_plan( $plan_slug );

			// check if plan exists, or create it
			if ( empty( $plan ) ) {
				$plan = $this->create_membership_plan( $which_plan );
			// if found, ensures the plan slug matches the requested one
			} elseif ( $plan->get_slug() !== $plan_slug ) {
				$plan = null;
			}
		}

		return $plan instanceof \WC_Memberships_Membership_Plan ? $plan : null;
	}


	/**
	 * Creates a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_plan plan slug
	 * @return null|\WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_Membership_Plan
	 */
	private function create_membership_plan( $which_plan ) {

		$plan      = null;
		$plan_slug = $this->add_prefix( $which_plan );
		$plan_data = $this->get_membership_plan_data( $which_plan );

		if ( is_array( $plan_data ) && isset( $plan_data['post_title'] ) ) {

			$post_id = wp_insert_post( array(
				'post_author' => get_current_user_id(),
				'post_type'   => 'wc_membership_plan',
				'post_status' => 'publish',
				'post_name'   => sanitize_text_field( $plan_slug ),
				'post_title'  => sanitize_text_field( $plan_data['post_title'] ),
			) );

			if ( is_numeric( $post_id ) ) {

				$plan   = new \WC_Memberships_Membership_Plan( $post_id );
				$access = isset( $plan_data['access_method'] ) ? $plan_data['access_method'] : 'manual-only';

				// set and validate access method
				$plan->set_access_method( $access );

				// set access products
				if ( 'purchase' === $plan->get_access_method() ) {

					// one product is picked at random to be the access product
					$random_product = array_rand( array_keys( $this->get_products_data() ), 1 );
					$access_product = $this->get_product( $random_product );

					// sanity check: revert to manual-only in case of errors
					if ( ! $access_product instanceof \WC_Product ) {
						$plan->set_access_method( 'manual-only' );
					} else {
						$plan->set_product_ids( $access_product->get_id() );
					}
				}

				// set plan rules
				$this->create_membership_plan_rules( $plan, $plan->get_rules() );
			}
		}

		return $plan;
	}


	/**
	 * Returns plan data given a membership plan slug.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_plan membership plan slug
	 * @return null|array plan data if data exists
	 */
	public function get_membership_plan_data( $which_plan ) {

		$plan = $this->remove_prefix( $which_plan );
		$data = $this->get_membership_plans_data();

		return ! empty( $data[ $plan ] ) ? $data[ $plan ] : array();
	}


	/**
	 * Returns data for plans to be created in bulk.
	 *
	 * @since 1.0.0
	 *
	 * @return array associative array of plans data with slugs shorthands for keys
	 */
	private function get_membership_plans_data() {

		return array(
			// a manually assigned plan
			'test-membership-plan-a' => array(
				'post_title'    => __( 'Test Membership Plan A (manual only)', 'woocommerce-dev-helper' ),
				'access_method' => 'manual-only',
			),
			// a signup-access membership plan
			'test-membership-plan-b' => array(
				'post_title'    => __( 'Test Membership Plan B (signup)', 'woocommerce-dev-helper' ),
				'access_method' => 'signup',
			),
			// a plan with products (simple, variable) to purchase to access to
			'test-membership-plan-c' => array(
				'post_title'    => __( 'Test Membership Plan C (purchase)', 'woocommerce-dev-helper' ),
				'access_method' => 'purchase',
			),
		);
	}


	/**
	 * Returns an array of plan slugs created by the bulk generator.
	 *
	 * @since 1.0.0
	 *
	 * @return string[] array of plan slugs
	 */
	public function get_membership_plans_slugs() {

		$plans = array();
		$slugs = array_keys( $this->get_membership_plans_data() );

		foreach ( $slugs as $slug ) {
			$plans[] = $this->add_prefix( $slug );
		}

		return $plans;
	}


	/**
	 * Creates rules for a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_User_Membership $plan plan object
	 * @param \WC_Memberships_Membership_Plan_Rule[] array of rules (default empty array as there are no rules yet)
	 */
	private function create_membership_plan_rules( $plan, array $rules ) {

		$rules = $this->create_membership_plan_content_access_rules( $plan, $rules );
		$rules = $this->create_membership_plan_products_access_rules( $plan, $rules );
		$rules = $this->create_membership_plan_products_purchase_rules( $plan, $rules );
		$rules = $this->create_membership_plan_products_discount_rules( $plan, $rules );

		$plan->set_rules( $rules );
	}


	/**
	 * Creates content access rules for a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_User_Membership $plan plan object
	 * @param \WC_Memberships_Membership_Plan_Rule[] array of rules (default empty array as there are no rules yet)
	 * @return \WC_Memberships_Membership_Plan_Rule[]
	 */
	private function create_membership_plan_products_access_rules( $plan, array $rules ) {

		// TODO
		return $rules;
	}


	/**
	 * Creates product purchase rules for a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_User_Membership $plan plan object
	 * @param \WC_Memberships_Membership_Plan_Rule[] array of rules (default empty array as there are no rules yet)
	 * @return \WC_Memberships_Membership_Plan_Rule[]
	 */
	private function create_membership_plan_products_purchase_rules( $plan, array $rules ) {

		// TODO
		return $rules;
	}


	/**
	 * Creates product discount rules for a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_User_Membership $plan plan object
	 * @param \WC_Memberships_Membership_Plan_Rule[] array of rules (default empty array as there are no rules yet)
	 * @return \WC_Memberships_Membership_Plan_Rule[]
	 */
	private function create_membership_plan_products_discount_rules( $plan, array $rules ) {

		// TODO
		return $rules;
	}


	/**
	 * Creates product access rules for a membership plan.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_User_Membership $plan plan object
	 * @param \WC_Memberships_Membership_Plan_Rule[] array of rules (default empty array as there are no rules yet)
	 * @return \WC_Memberships_Membership_Plan_Rule[]
	 */
	private function create_membership_plan_content_access_rules( $plan, array $rules ) {

		// TODO
		return $rules;
	}


	/**
	 * Returns a product for use by the generator, creates one if doesn't exist.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_product the product slug
	 * @return null|\WC_Product
	 */
	private function get_product( $which_product ) {

		$product = null;

		if ( $product_data = $this->get_product_data( $which_product ) ) {

			$product_posts = get_posts( array(
				'name'           => $this->add_prefix( $which_product ),
				'post_type'      => 'product',
				'post_status'    => 'any',
				'posts_per_page' => 1,
			) );

			if ( is_array( $product_posts ) && isset( $product_posts[0] ) ) {
				$product = wc_get_product( $product_posts[0] );
			} else {
				$product = $this->create_product( $which_product );
			}
		}

		return $product instanceof \WC_Product ? $product : null;
	}


	/**
	 * Creates a product for use by the generator.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_product product data to retrieve
	 * @return null|\WC_Product
	 */
	private function create_product( $which_product ) {

		$product      = null;
		$product_slug = $this->add_prefix( $which_product );
		$product_data = $this->get_product_data( $which_product );

		if ( isset( $product_data['post_title'] ) ) {

			$product_id = wp_insert_post( array(
				'post_author' => get_current_user_id(),
				'post_type'   => 'product',
				'post_status' => 'publish',
				'post_name'   => sanitize_text_field( $product_slug ),
				'post_title'  => sanitize_text_field( $product_data['post_title'] ),
			) );

			if ( is_numeric( $product_id ) ) {

				$product = new \WC_Product_Simple( $product_id );

				$product->set_price( isset( $product_data['price'] ) ? (float) $product_data['price'] : 0 );
				$product->save();
			}
		}

		return $product;
	}


	/**
	 * Returns product data used by the generator.
	 *
	 * @since 1.0.0
	 *
	 * @param string $which_product product slug
	 * @return array|null
	 */
	private function get_product_data( $which_product ) {

		$product = $this->remove_prefix( $which_product );
		$data    = $this->get_products_data();

		return ! empty( $data[ $product ] ) ? $data[ $product ] : array();
	}


	/**
	 * Returns data for products to be created in bulk.
	 *
	 * @since 1.0.0
	 *
	 * @return array
	 */
	private function get_products_data() {

		return array(
			'simple-product-a' => array(
				'post_title' => __( 'Simple Product A', 'woocommerce-dev-helper' ),
				'price' => 1,
			),
			'simple-product-b' => array(
				'post_title' => __( 'Simple Product B', 'woocommerce-dev-helper' ),
				'price' => 10
			),
			'simple-product-c' => array(
				'post_title' => __( 'Simple Product C', 'woocommerce-dev-helper' ),
				'price'      => 19.80,
			),
		);
	}


	/**
	 * Records newly created objects to the job.
	 *
	 * This allows to save them to an option when the job has completed and let the bulk destroyer eliminate them when engaged.
	 *
	 * @since 1.0.0
	 *
	 * @param \WC_Memberships_Membership_Plan|\WC_Memberships_Integration_Subscriptions_Membership_Plan $membership_plan plan object
	 * @param \stdClass $job background job object
	 * @return \stdClass modified job
	 */
	private function record_objects_ids( $membership_plan, $job ) {

		// store the membership plan's own ID
		$job = $this->record_object_id( $job, 'plans', $membership_plan->get_id() );

		// add products that grant access
		foreach ( $membership_plan->get_product_ids() as $product_id ) {
			$job = $this->record_object_id( $job, 'products', $product_id );
		}

		// add posts and products created from plan rules
		foreach ( $membership_plan->get_rules() as $rule ) {

			$content_type_name = $rule->get_content_type_name();

			// TODO record taxonomy terms (categories, product cats...) {FN 2018-09-17}

			foreach ( $rule->get_object_ids() as $object_id ) {
				if ( 'post' === $content_type_name ) {
					$job = $this->record_object_id( $job, 'posts', $object_id );
				} elseif ( 'product' === $content_type_name ) {
					$job = $this->record_object_id( $job, 'products', $object_id );
				}
			}
		}

		return $job;
	}


	/**
	 * Adds an ID record to the job.
	 *
	 * @see Bulk_Generator::get_objects_keys() for a list of valid keys
	 *
	 * @since 1.0.0
	 *
	 * @param null|\stdClass $job job object
	 * @param string $key job property
	 * @param int $id WordPress object ID
	 * @return null|\stdClass
	 */
	private function record_object_id( $job, $key, $id ) {

		if ( null !== $job && isset( $job->objects ) && is_numeric( $id ) && (int) $id > 0 && in_array( $key, $this->get_objects_keys(), true ) ) {

			if ( ! isset( $job->objects[ $key ] ) ) {
				$job->objects[ $key ] = array();
			} else {
				$job->objects[ $key ] = (array) $job->objects[ $key ];
			}

			if ( ! in_array( (int) $id, (array) $job->objects[ $key ], true ) ) {
				$job->objects[ $key ][] = (int) $id;
			}
		}

		return $job;
	}


	/**
	 * Adds a prefix to a string.
	 *
	 * @since 1.0.0
	 *
	 * @param string $slug a string which may already include a prefix, or not
	 * @return string
	 */
	private function add_prefix( $slug ) {

		return 0 !== strpos( $slug, $this->prefix ) ? "{$this->prefix}_{$slug}" : $slug;
	}


	/**
	 * Removes a prefix from a string.
	 *
	 * @since 1.0.0
	 *
	 * @param string $slug a string which may or may not include the prefix already
	 * @return string
	 */
	private function remove_prefix( $slug ) {

		return 0 === strpos( $slug, "{$this->prefix}_" ) ? substr( $slug, strlen( "{$this->prefix}_" ) ) : $slug;
	}


}
